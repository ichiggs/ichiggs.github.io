<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Lorenz Attractor Ensemble Demo</title>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
<style>
  body { margin: 0; background: black; color: #eeeeee; font-family: sans-serif; display: flex; flex-direction: column; height: 100vh; }
  
  /* Header */
  #header {
    padding: 20px;
    background: rgba(0,0,0,0.85);
    text-align: center;
    max-width: 840px;
    margin: 0 auto;
  }
  #header h1 { margin: 0 0 10px 0; font-size: 2em; }
  #header p { margin: 5px 0; font-size: 1em; line-height: 1.5; }

  /* Buttons */
  #buttons {
    display: flex;
    justify-content: center;
    gap: 10px;
    padding: 10px 0;
    background: rgba(0,0,0,0.85);
  }
  #buttons button { font-size: 1em; padding: 8px 12px; cursor: pointer; }

  /* Name */
  #footer {
    position: fixed;
    bottom: 10px;
    right: 10px;
    color: #cccccc;
    font-size: 0.9em;
    background: rgba(0,0,0,0.5);
    padding: 4px 8px;
    border-radius: 4px;
    z-index: 20;
  }

  /* Canvas */
  #canvas-container { flex: 1; position: relative; }
  canvas { width: 100%; height: 100%; display: block; }
</style>
</head>
<body>

<div id="header">
  <h1>Computational Chaos: The Lorenz '63 Attractor</h1>
  <p>The Lorenz system is a set of simple equations that can create surprisingly complex and unpredictable patterns:</p>
  <p>
    $$\begin{aligned}
    \dot{x} &= \sigma (y - x) \\
    \dot{y} &= x(\rho - z) - y \\
    \dot{z} &= xy - \beta z
    \end{aligned}$$
  </p>
  <p>Tiny differences in where you start can lead to wildly different results - this is often referred to as the “butterfly effect.”</p>

  <p><b>Reset</b> and watch how these tiny differences can grow into large differences over time!</p>
</div>

<div id="buttons">
  <button id="resetBtn">Reset</button>
  <button id="rotateBtn">Rotate</button>
</div>


<div id="canvas-container">
  <canvas id="canvas"></canvas>
</div>

<div id="header">
 <p>By simulating chaotic systems and analysing them with algorithms, we can uncover hidden patterns, gain new insights, and develop techniques for real-world challenges like predicting the weather!</p>
</div>

<div id="footer">Created by Dr. Ieuan Higgs (UoR:CS)</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
    canvas.width = canvas.parentElement.clientWidth;
    canvas.height = canvas.parentElement.clientHeight*0.8;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

const width = canvas.width;
const height = canvas.height;

// Lorenz parameters
const sigma = 10, rho = 28, beta = 8/3;
const dt = 0.01;

// Ensemble
const numMembers = 20;
const members = [];
const tailLength = 50;

// Initialize members
for(let i = 0; i < numMembers; i++) {
    members.push({
        x: Math.random()*10 - 5,
        y: Math.random()*10 - 5,
        z: Math.random()*10 - 5,
        tail: []
    });
}

// Lorenz integration (Euler)
function lorenzStep(member) {
    const {x, y, z} = member;
    const dx = sigma*(y - x) * dt;
    const dy = (x*(rho - z) - y) * dt;
    const dz = (x*y - beta*z) * dt;
    member.x += dx;
    member.y += dy;
    member.z += dz;

    member.tail.push({x: member.x, y: member.y, z: member.z});
    if(member.tail.length > tailLength) member.tail.shift();
}

// Rotation state
let rotate = false;
let angle = 0;

// Buttons
document.getElementById('rotateBtn').onclick = () => rotate = !rotate;

document.getElementById('resetBtn').onclick = () => {
    const leader = members[0];
    const epsilon = 0.05;
    for(let i = 1; i < numMembers; i++) {
        members[i].x = leader.x + (Math.random()*2 - 1)*epsilon;
        members[i].y = leader.y + (Math.random()*2 - 1)*epsilon;
        members[i].z = leader.z + (Math.random()*2 - 1)*epsilon;
        members[i].tail = [...leader.tail];
    }
};

// Projection with optional rotation
function project(x, y, z) {
    const scale = 9;
    if(rotate) {
        const cosA = Math.cos(angle);
        const sinA = Math.sin(angle);
        const xr = x * cosA - y * sinA;
        const yr = x * sinA + y * cosA;
        return { x: canvas.width/2 + scale*xr*1.5, y: canvas.height*0.8 - scale*z + scale*10};
    } else {
        return { x: canvas.width/2 + scale*x*1.5, y: canvas.height*0.8 - scale*z + scale*10};
    }
}

function animate() {
    ctx.fillStyle = 'rgba(0,0,0,0.1)';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    if(rotate) angle += 0.005;
    else angle = 0;

    members.forEach((m, idx) => {
        lorenzStep(m);

        ctx.beginPath();
        m.tail.forEach((pos, i) => {
            const p = project(pos.x, pos.y, pos.z);
            if(i===0) ctx.moveTo(p.x,p.y);
            else ctx.lineTo(p.x,p.y);
        });
        ctx.strokeStyle = `hsl(${(idx/numMembers)*360}, 100%, 50%)`;
        ctx.lineWidth = 2;
        ctx.stroke();
    });

    requestAnimationFrame(animate);
}

animate();
</script>

</body>
</html>
