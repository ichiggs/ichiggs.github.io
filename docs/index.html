<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rotating Globe (D3)</title>
  <style>
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
    .wrap{display:flex;align-items:center;justify-content:center;height:100%;background:linear-gradient(#0b1220,#081018);color:#fff}
    .card{width:min(960px,95vw);aspect-ratio:16/9;background:linear-gradient(180deg,rgba(255,255,255,0.03),rgba(255,255,255,0.01));border-radius:12px;padding:12px;box-shadow:0 8px 30px rgba(2,6,23,0.6);display:flex;flex-direction:column}
    header{display:flex;align-items:center;gap:12px}
    h1{font-size:16px;margin:0;font-weight:600}
    p{margin:0;color:#aab3c0;font-size:12px}
    svg{flex:1;width:100%;height:100%;display:block;border-radius:8px}
    .credits{font-size:11px;color:#8892a0;margin-top:8px}
    /* cursor styles while interacting */
    .grabbing{cursor:grabbing!important}
    .grab{cursor:grab!important}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <header>
        <div>
          <h1>Interactive Rotating Globe â€” drag to spin</h1>
          <p>Random red shades for countries. Auto-rotates when idle.</p>
        </div>
      </header>
      <svg id="globe"></svg>
      <div class="credits">Uses D3.js and World Atlas topojson (remote). Open in a browser with network access.</div>
    </div>
  </div>

  <!-- D3 and topojson via CDN -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://unpkg.com/topojson-client@3/dist/topojson-client.min.js"></script>
  <script>
    // Configuration
    const width = 960;
    const height = 540;

    const svg = d3.select('#globe')
      .attr('viewBox', `0 0 ${width} ${height}`)
      .attr('preserveAspectRatio', 'xMidYMid meet');

    const projection = d3.geoOrthographic()
      .scale((Math.min(width, height) / 2) - 20)
      .translate([width / 2, height / 2])
      .clipAngle(90);

    const path = d3.geoPath(projection);

    // Grouping
    const g = svg.append('g');

    // Globe land/water
    g.append('circle')
      .attr('cx', width / 2).attr('cy', height / 2)
      .attr('r', projection.scale())
      .attr('fill', '#021323');

    // Graticule
    const graticule = d3.geoGraticule10();
    g.append('path')
      .datum(graticule)
      .attr('d', path)
      .attr('fill', 'none')
      .attr('stroke', 'rgba(255,255,255,0.04)')
      .attr('stroke-width', 0.5);

    // Country group
    const countriesG = g.append('g').attr('class','countries');

    // Utility: pick a random red shade
    function randomRed() {
      // random hue near red, vary lightness
      const r = Math.floor(160 + Math.random() * 95); // red channel high
      const g = Math.floor(Math.random() * 100);
      const b = Math.floor(Math.random() * 100);
      // slightly desaturate to stay in 'red family'
      return `rgb(${r},${g},${b})`;
    }

    // Load world topojson
    d3.json('https://unpkg.com/world-atlas@2/world/110m.json').then(world => {
      const land = topojson.feature(world, world.objects.countries);

      // Create a random color for each country
      const colorById = new Map();
      land.features.forEach(f => colorById.set(f.id, randomRed()));

      // Draw countries
      countriesG.selectAll('path')
        .data(land.features)
        .enter().append('path')
          .attr('d', path)
          .attr('fill', d => colorById.get(d.id))
          .attr('stroke', 'rgba(0,0,0,0.25)')
          .attr('stroke-width', 0.3);

      // subtle highlight for visible hemisphere
      countriesG.append('path')
        .datum({type: 'Sphere'})
        .attr('d', path)
        .attr('fill', 'none')
        .attr('stroke', 'rgba(255,255,255,0.06)')
        .attr('stroke-width', 1.2);

      startInteraction();
    }).catch(err => {
      console.error('Failed to load world topojson. This demo requires network access.', err);
      svg.append('text')
        .attr('x', width/2).attr('y', height/2)
        .attr('text-anchor','middle')
        .attr('fill','#ffb3b3')
        .text('Failed to load world data (network required)');
    });

    // Rotation / interaction logic
    let rotation = [0, -20, 0]; // [lambda, phi, roll]
    let velocity = 0.02; // degrees per ms for auto-rotation (lambda)
    let lastTime = Date.now();
    let dragging = false;

    // Inertial spin state
    let inertia = {vx:0, vy:0, lastT:0};

    function render() {
      projection.rotate(rotation);
      svg.selectAll('path').attr('d', path);
    }

    // Auto-rotate timer
    function tick() {
      const now = Date.now();
      const dt = now - lastTime;
      lastTime = now;

      if (!dragging) {
        // apply small auto-rotation around longitude
        rotation[0] += velocity * dt;
      } else {
        // while dragging, apply inertia to rotation if any
        if (Math.abs(inertia.vx) > 0.00001 || Math.abs(inertia.vy) > 0.00001) {
          rotation[0] += inertia.vx * dt;
          rotation[1] += inertia.vy * dt;
          // decay
          inertia.vx *= Math.exp(-0.002 * dt);
          inertia.vy *= Math.exp(-0.002 * dt);
        }
      }

      // constrain latitude rotation
      rotation[1] = Math.max(-90, Math.min(90, rotation[1]));

      render();
      requestAnimationFrame(tick);
    }

    // Drag behavior
    function startInteraction() {
      const drag = d3.drag()
        .on('start', (event) => {
          dragging = true;
          inertia.vx = inertia.vy = 0;
          svg.classed('grabbing', true).classed('grab', false);
        })
        .on('drag', (event) => {
          // event.dx/dy are in screen pixels. Convert to degrees using scale factor.
          const sens = 0.25; // sensitivity
          const dx = event.dx * sens;
          const dy = event.dy * sens;
          rotation[0] += dx;
          rotation[1] -= dy;

          // store instantaneous velocity for inertia
          const now = Date.now();
          const dt = Math.max(1, now - (inertia.lastT || now));
          inertia.vx = dx / dt; // deg per ms
          inertia.vy = -dy / dt;
          inertia.lastT = now;

          render();
        })
        .on('end', (event) => {
          dragging = false;
          svg.classed('grabbing', false).classed('grab', true);
          // keep inertia.vx/vy as set; they'll decay in tick loop
        });

      svg.call(drag).classed('grab', true);

      // start the animation loop
      lastTime = Date.now();
      requestAnimationFrame(tick);
    }

    // Make responsive: recompute projection on resize
    function resize() {
      const rect = svg.node().getBoundingClientRect();
      const s = Math.min(rect.width, rect.height) / 2 - 10;
      projection
        .scale(s)
        .translate([rect.width/2, rect.height/2]);

      // update globe circle radius
      g.selectAll('circle').attr('cx', rect.width/2).attr('cy', rect.height/2).attr('r', s);
      render();
    }

    // Observe size changes
    new ResizeObserver(resize).observe(svg.node());

  </script>
</body>
</html>
